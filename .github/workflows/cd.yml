name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request: # Also run checks on Pull Requests
    branches: [main]

env:
  GHCR_REGISTRY: ghcr.io
  IMAGE_BASENAME: ${{ github.repository_owner }}/${{ github.event.repository.name }}

jobs:
  lint-test:
    name: Lint & Test Backend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend # Run commands within backend dir

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

  build-push:
    name: Build & Push Docker Images
    needs: lint-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Lowercase Image Base Name
        id: lowercaser
        run: echo "image_base=$(echo ${{ env.IMAGE_BASENAME }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Define Image Tags
        id: image_tags
        run: |
          TAG_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "tag_sha=${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "tag_latest=latest" >> $GITHUB_OUTPUT
          echo "backend_image=${{ steps.lowercaser.outputs.image_base }}/backend" >> $GITHUB_OUTPUT
          echo "frontend_image=${{ steps.lowercaser.outputs.image_base }}/frontend" >> $GITHUB_OUTPUT

      - name: Build and Push Backend Image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ steps.image_tags.outputs.backend_image }}:${{ steps.image_tags.outputs.tag_latest }}
            ${{ env.GHCR_REGISTRY }}/${{ steps.image_tags.outputs.backend_image }}:${{ steps.image_tags.outputs.tag_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and Push Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ steps.image_tags.outputs.frontend_image }}:${{ steps.image_tags.outputs.tag_latest }}
            ${{ env.GHCR_REGISTRY }}/${{ steps.image_tags.outputs.frontend_image }}:${{ steps.image_tags.outputs.tag_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Server
    needs: build-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Define Image Tags for Deployment
        id: image_tags
        run: |
          TAG_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_BASE_LOWER=$(echo "${{ env.IMAGE_BASENAME }}" | tr '[:upper:]' '[:lower:]')
          echo "backend_image=${{ env.GHCR_REGISTRY }}/${IMAGE_BASE_LOWER}/backend:${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "frontend_image=${{ env.GHCR_REGISTRY }}/${IMAGE_BASE_LOWER}/frontend:${TAG_SHA}" >> $GITHUB_OUTPUT

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.SERVER_PORT }} ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare Remote Directory and Transfer Files
        run: |
          # Define the deployment directory ON THE SERVER (relative to user's home)
          DEPLOY_DIR="~/deployments/rust-actix-web_cd" # Use ~ for home directory

          echo "Creating directory ${DEPLOY_DIR} on server..."
          ssh -p ${{ secrets.SERVER_PORT }} -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p ${DEPLOY_DIR}"

          echo "Transferring files..."
          # Copy docker-compose.yml
          scp -P ${{ secrets.SERVER_PORT }} -i ~/.ssh/deploy_key docker-compose.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${DEPLOY_DIR}/docker-compose.yml
          # Copy nginx.conf TO THE SAME DIRECTORY AS docker-compose.yml
          scp -P ${{ secrets.SERVER_PORT }} -i ~/.ssh/deploy_key ./frontend/nginx.conf ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${DEPLOY_DIR}/nginx.conf
          # Copy deploy script
          scp -P ${{ secrets.SERVER_PORT }} -i ~/.ssh/deploy_key ./deployment/scripts/deploy.sh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${DEPLOY_DIR}/deploy.sh

          echo "Making deploy script executable..."
          ssh -p ${{ secrets.SERVER_PORT }} -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "chmod +x ${DEPLOY_DIR}/deploy.sh"

      - name: Execute Deployment on Server
        env:
          GHCR_PAT_OR_TOKEN: ${{ secrets.GHCR_PAT_OR_TOKEN }}

          PROD_COMPOSE_PROJECT_NAME: "rust-actix-web_cd" # Example: Use a specific prod name
          PROD_RUST_LOG: "warn"
          PROD_HOST_PORT_FRONTEND: "90" # Typically 80 or 443 (via proxy)
          PROD_FRONTEND_INTERNAL_PORT: "8090" # Update if your nginx container listens on 80
          PROD_BACKEND_INTERNAL_PORT: "8091" # Match your backend app's listen port
          PROD_DATABASE_URL: "sqlite:/app/data/whoknows.db" # Or from secrets: ${{ secrets.SERVER_DATABASE_URL }}
        run: |
          DEPLOY_DIR="~/deployments/rust-actix-web_cd" # Consistent path

          echo "Connecting to server to perform deployment..."
          ssh -p ${{ secrets.SERVER_PORT }} -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << EOF
            echo "Changing to deployment directory: ${DEPLOY_DIR}"
            cd ${DEPLOY_DIR} || exit 1 # Exit if cd fails

            # --- Set environment variables ON THE SERVER ---
            # These will be used by docker-compose when it runs
            echo "Exporting environment variables for docker-compose..."
            export IMAGE_TAG_BACKEND="${{ steps.image_tags.outputs.backend_image }}"
            export IMAGE_TAG_FRONTEND="${{ steps.image_tags.outputs.frontend_image }}"

            # Use the production values defined in the 'env:' block above
            export COMPOSE_PROJECT_NAME="${PROD_COMPOSE_PROJECT_NAME}"
            export RUST_LOG="${PROD_RUST_LOG}"
            export HOST_PORT_FRONTEND="${PROD_HOST_PORT_FRONTEND}"
            export FRONTEND_INTERNAL_PORT="${PROD_FRONTEND_INTERNAL_PORT}"
            export BACKEND_INTERNAL_PORT="${PROD_BACKEND_INTERNAL_PORT}"
            export DATABASE_URL="${PROD_DATABASE_URL}"

            # --- Login, Deploy, Logout ---
            echo "Logging into GHCR..."
            # Use the secret passed via the runner's env block
            echo "${GHCR_PAT_OR_TOKEN}" | docker login ${{ env.GHCR_REGISTRY }} -u ${{ github.actor }} --password-stdin

            echo "Running deployment script (./deploy.sh)..."
            # Execute the script. It inherits the exported variables.
            ./deploy.sh

            echo "Logging out from GHCR..."
            docker logout ${{ env.GHCR_REGISTRY }}

            echo "Deployment commands finished."
          EOF

          echo "SSH deployment execution complete."
